# Chapter 1. 스코프란 무엇인가
프로그래밍 언어의 기본 패러다임중 하나는 변수에 값을 저장하고, 저장된 값을 가져다 쓰거나 수정하는 기능이다.

`스코프`란 이러한 변수를 특정 장소에 저장하고, 해당 변수를 찾는 일련의 규칙을 의미한다.

## 1.1 컴파일러 이론
자바스크립트는 `동적` 혹은 `인터프리터` 언어로 분류되지만, 엄밀하게는 `컴파일러` 언어이다. <br>
( 런타임에서 자바스크립트 코드가 실행될 때, 컴파일레이션 과정을 거치기 때문 )

하지만 자바스크립트는 일반적인 컴파일러 언어들처럼 미리 코드를 컴파일하거나 컴파일한 결과를 분산시스템에서 사용할 수 있는것은 아니다.

컴파일러 언어들은 코드가 실행되기전에 3단계이 과정을 거치는 데, 이를 `컴파일레이션(Compilation)` 이라고 한다. 

### 토크나이징(Tokenizing) / 렉싱(Lexing)
토크나이징은 코드 문자를 `토큰(token)`이라 불리는 (해당 언어의)의미 있는 조각으로 만드는 과정이다.
예를 들면

```js
var a = 2;
```
위와 같은 코드는
- var
- a
- = 
- 2
- ;
으로 토큰화 된다.

@ 토크나이징과 렉싱은 학술적으로 미묘한 차이가 있는데, 전자는 무상태 방식을 의미하고, 후자는 상태유지 방식으로 나뉘며, 이는 `토크나이저(Tokenizer)`가  `상태유지 파싱 규칙`을 적용해 `a`가 별개의 토큰인지 다른 토큰의 일부인지를 파악한다면 렉싱이다. ( 토큰이 상관관계? 등을 파악해가며 토크나이징을 하는 경우와 아닌경우를 의미 하는것 같음 )

### 파싱(Parsing)
토큰 배열을 프로그램의 문법 구조를 반영하여, 중첩 원소를 가지는 트리 형태의 구조로 바꾸는 과정.
이 과정을 거쳐 만들어진 트리를 `AST(Abstract Syntax Tree)`라고 부른다.

위 예제에서 `var a = 2;`는 변수 선언이라 부르는 최상위 노드에서 시작하고, 최상위 노드는 확인자 `a`와 대입수식이라 불리는 `=`를 자식노드를 갖는다. 

그리고 대입수식 노드인 `=`은 `2`라는 숫자 리터럴을 자식 노드로 가지며, 이를 트리로 표현하면 아래와 같다.


```
var
└── a
└── =
    └── 2
```

### 코드생성(Code-Generation)
파싱과정에서 생성된 AST를 컴퓨터에서 실행할 코드로 변환하는 과정이다. 해당 부분은 언어 혹은 플랫폼에 따라 크게 달라진다.

자바스크립트는 미리 컴파일되는 언어가 아니기 때문에, 위 세단계의 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시의 성능을 최적화 한다.

## 1.2 스코프 이해하기
스코프는 컴파일러나 엔진이 코드 생성과 코드 실행에 필요한 변수에 대해서 해당 값이 존재하는지 아닌지에 대한 정보를 스코프 컬렉션안에 있는지 확인하여준다.? 

## LHS(Left-hand Side)와 RHS(Right-hand Side)
엔진이 검색을 하는 종류로, LHS는 왼쪽 방향, RHS 오른쪽 방향 검색을 의미힌다.

하지만, 엄밀하게 본다면 왼쪽과 오른쪽 구분이라기 보다는 `왼편`과 `왼편이 아닌쪽`에 가깝다

LHS 검색은 값을 넣어야 하는(대입하여야 하는) 경우에 실행되는 검색으로, 변수 컨테이너 자체를 찾고,

RHS 검색은 단순히 특정 변수의 값을 찾는것과 다름이 없다.

- 대입할 대상(LHS), 대입한 값(RHS)

```
var a = 2;
``` 
위 예제에서는 2라는 숫자 리터럴값을 대압해야할 변수 a를 찾아야하므로 LHS 검색이 실행된다.

```
console.log(a);
```
위 예제에서는 a에 대하여 콘솔을 출력할 값이 필요하므로, RHS 검색을 실행한다.

## 1.3 중첩 스코프
하나의 스코프는 다른 스코프 안에 중첩될 수 있는데, 스코프간 교집합이 일어날 수는 없다.
찾고자 하는 변수를 현재 스코프에서 찾지 못했을 경우, 중첩된 스코프 구조에서, 현재 스코프의 부모 스코프로 영역을 넓혀 찾는다. ( `스코프 체인` 혹은 `스코프 버블` ) 이와 같은 과정은 가장 바깥 스코프(글로벌 스코프 / 웹 환경에서는 `window`객체)에 도달 할 때까지 반복된다. ( 도중에 찾았다면 멈춘다. )

스코프 체인은 자식에서 부모방향으로만 진행되고, 반대로는 불가능하다. (bottom-up)

## 1.4 오류
엔진이 검색하는 방식을 LHS와 RHS로 구분하는 것은, 검색하고자 하는 변수를 가능한 모든 스코프에서 찾지 못했을 경우에 다르게 동작하기 때문이다.

RHS의 경우 찾고자 하는 변수를 찾지 못하면, 다시는 해당 변수를 찾을 수 없고, 이렇게 스코프에서 찾지 못한 변수를 `선언되지 않은 변수`라고 한다. 이 경우 엔진은 `Reference Error`를 발생시킨다.

RHS검색에서 값을 찾았지만, 가능하지 않은 동작을 하려고 한다면, `Type Error`를 발생시킨다. (null혹은 undefined 값을 참조하거나, 함수가 아닌 변수를 함수처럼 실행할 경우)

반면, `Strict Mode`가 아닌경우에서 LHS검색이 실패할 경우, 엔진은 글로벌 스코프에 해당 변수를 생성한다.
`Strict Mode`에서는 LHS검색이 실패할 경우, RHS와 마찬가지로 `Reference Error`를 발생시킨다.